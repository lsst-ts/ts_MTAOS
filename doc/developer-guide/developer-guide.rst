.. _Developer_Guide:

#########################
MTAOS Developer Guide
#########################

This CSC is a *ts_salobj* based control system integrating the middleware layer and the high-level state machine.
The Active Optics System (AOS) algorithms depends on the Wavefront Estimation Pipeline (WEP) and the Optical Feedback Control (OFC) modules: *ts_wep* and *ts_ofc*.

.. _Dependencies:

Dependencies
============

* `ts_salobj <https://github.com/lsst-ts/ts_salobj>`_
* `ts_config_mttcs <https://github.com/lsst-ts/ts_config_mttcs>`_
* `ts_wep <https://github.com/lsst-ts/ts_wep>`_
* `ts_ofc <https://github.com/lsst-ts/ts_ofc>`_

.. _Architecture:

Architecture
=============

The classes in module are listed below.

.. uml:: ../uml/mtaosClass.uml
    :caption: Class diagram of MTAOS

* **MtaosCsc** is a CSC class. It inherits from the *ts_salobj*'s **ConfigurableCsc**. *ts_salobj* provides interfaces for the SAL communication.
* **CollOfListOfWfErr**: Collection of list of wave-front sensor data.
* **Config**: Configuration class. Holds configuration values and provides functions to retrieve the configurable values.
* **Model**: Model class containing the *ts_wep* and *ts_ofc* interface classes. Together with WEP and OFC it runs the wavefront analysis and corrects the hexapod position and mirror bending mode.

Only the **MtaosCsc** instance has knowledge of the high-level control logic and middleware layer provided by **ConfigurableCsc**.
The business logic is implemented in the **Model**.
This allows for testing **Model** without SAL integration.

.. _API:

APIs
=============

This section is autogenerated from docstrings.

.. automodapi:: lsst.ts.mtaos
    :no-inheritance-diagram:

.. _Build_And_Test:

Build and Test
==============

Using `docker <https://www.docker.com>`_ is highly recommended.
The Docker files can follow various MTAOS Dockerfiles from `ts_Dockerfiles <https://github.com/lsst-ts/ts_Dockerfiles>`_.

There are three docker images related to MTAOS: `aos_sal <https://hub.docker.com/repository/docker/lsstts/aos_sal>`_, `aos_aoclc <https://hub.docker.com/repository/docker/lsstts/aos_aoclc>`_, and `mtaos_sim <https://hub.docker.com/repository/docker/lsstts/mtaos_sim>`_.
The *aos_sal* image contains the SAL and eups packages used in AOS.
The *aos_aoclc* image contains WEP and OFC packages.
The *mtaos_sim* image contains the *ts_MTAOS* simulator.

To build and test the CSC using Docker, enter:

.. code-block:: bash

    docker run -it -v ${repos_location}:/home/saluser/develop lsstts/aos_aoclc:${tag}
    make_idl_files.py MTAOS Hexapod MTM1M3 MTM2
    cd develop/ts_MTAOS
    setup -k -r .
    scons

The environment shall be setup either from */home/saluser/.setup.sh* or */home/saluser/.setup_dev.sh*.

.. _Usage:

Usage
=====

To start the *MTAOS* CSC, enter the following command:

.. prompt:: bash

    python bin/run_mtaos.py

You can setup the path of Instrument Signature Removal (ISR) for the butler to use before running the CSC: ``export ISRDIRPATH=${path_to_isr_directory}``.
The butler is the middleware used in scientific pipeline or *lsst_distrib* package.

You can use the argument of *-s* to run the simulation mode or *-h* to get all available argument details.
For example, you can use the argument of *--logToFile* to log messages to a log file.
Python *logging* package is used, with default log level set to *DEBUG*.
The log level can be adjusted with *--debugLevel* argument.

Stopping the CSC is done by SIG-INTing the process, usually by :kbd:`ctrl` + :kbd:`c`.

Utilities
=========

This section provide some documentation of the utility methods available in MTAOS.

timeit
------

MTAOS provides the :py:meth:`timeit <lsst.ts.mtaos.utility.timeit>` decorator that allows one compute and store execution times of methods and coroutines.
To add the decorator the method must either support ``kwargs`` argument or contain an additional parameter named ``log_time``, which must receive a dictionary.
The dictionary passed to ``log_time`` will receive a new item, with the name of the method in upper case as the key, and a list as value.
The decorator will append the execution time to the list every time the method is called.

You can use the :py:meth:`timeit <lsst.ts.mtaos.utility.timeit>` decorator as follows:

.. code-block:: python

  from lsst.ts.mtaos import timeit

  # timing a regular method.
  @timeit
  def my_method(arg1, arg2, **kwargs):
    ...


  # timing a coroutine
  @timeit
  async def my_coroutine(arg1, agr2, **kwargs):
    ...

  log_time = dict()

  ret_val_1 = my_method(arg1=arg1, arg2=arg2, log_time=log_time)

  ret_val_2 = await my_coroutine(arg1=arg1, arg2=arg2, log_time=log_time)

The dictionary ``log_time``, will now contain two entries; ``MY_METHOD`` and ``MY_COROUTINE``, each containing a list with the execution time of each call.

.. _Contributing:

Contributing
============

To contribute, please start a new pull request on `GitHub <https://github.com/lsst-ts/ts_MTAOS>`_.
Feature requests shall be filled in JIRA with the *ts_MTAOS* or *MTAOS* label.
In all cases, reaching out to the :ref:`contacts for this CSC <Contact_Personnel>` is recommended.
