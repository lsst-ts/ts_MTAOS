.. _User_Guide:

################
MTAOS User Guide
################

In automatic mode, the Telescope Control System (TCS) triggers *MTAOS* image processing.
MTAOS then sends commands to M1M3, M2, and M2/camera hexapod with the corrections to attain the best alignment of optical system.
*MTAOS* coordinates functions of the Wavefront Estimation Pipeline (WEP) and the Optical Feedback Control (OFC).
WEP processes defocal images and calculates wavefront error based on the Transport of Intensity Equation (TIE).
Wavefront error is then feeded into OFC.
OFC estimates current optical state and calculates corrections values.
Correction values are estimated by minimizing the cost function balancing the image quality and offsets in the controlled Degrees Of Freedom (DOF).
There are 50 controlled DOFs.
M1M3 and M2 each has 20 bending modes.
The camera and M2 hexapods each has 5 DOFs (x, y, z and x and y rotation).
Although the optical surfaces bending modes are controlled directly by MTAOS, the corrections commands send from MTAOS contains aggregated actuator forces (transformed from the bending mode).

.. _Interface:

Interface
=========

The full set of commands, events, and telemetry can be found on `MTAOS xml <https://ts-xml.lsst.io/sal_interfaces/MTAOS.html>`_.
The principal use-case for this CSC is to calculate the wavefront error and send the corrections to the optical surfaces.
The ``processCalibrationProducts`` command ingests the calibration data used during analysis such as the flat images.
The ``processIntraExtraWavefrontError`` command processes wavefront data of the commissioning camera (ComCam).
*Currently only ComCam is supported.*
Artificial defocal images can be generated by `PhoSim <https://github.com/lsst-ts/phosim_syseng4>`_.
Artificial flat images can be computed by `phosim_utils <https://github.com/lsst-dm/phosim_utils>`_.
Multiple (e.g. 5) pairs of wavefront images can be processed.

The ``issueWavefrontCorrection`` command sends the corrections to subsystems.
If multiple defocal images are presented on input, the average of calculated wavefront error is used for each CCD.
Internal data such as the DOF can be reset by ``resetWavefrontCorrection`` command.
The data shall be reset e.g. after a long telescope slew.

Although not often required, MTAOS publishes the calculated wavefront error in the ``wavefrontError`` event and DOF in the ``degreeOfFreedom`` event.
The ``wepDuration`` and ``ofcDuration`` events can be used to analyze system performance.
The ``wepDuration`` event is published for each CCD.
The mapping between sensor names and their IDs can be found `here <https://github.com/lsst-ts/ts_wep/blob/master/policy/sensorNameToId.yaml>`_.

If some subsystem(s) reject the correction command(s) from MTAOS, the ``rejectedDegreeOfFreedom`` event is published.
To recover, subsystems whose accepted the correction command might need to be put into a previous state to be consistent with the MTAOS internal data.
It is expected that during automatic operations recovery will be handled by the TCS or a higher level script.

.. _Example_Use_Case:

Example Use-Case
================

This example discusses Commanding from Python script. Commanding from other CSCs is expected during routine operations.

After importing *ts_salobj* module, **Remote** object, a proxy for MTAOS CSC, is created.
The ``salobj.set_summary_state()`` call is used to switch to *ENABLED* state.

.. code:: python

    from lsst.ts import salobj
    mtaosCsc = salobj.Remote(salobj.Domain(), "MTAOS")
    await mtaosCsc.start_task
    await salobj.set_summary_state(mtaosCsc, salobj.State.ENABLED, timeout=30)

The optional *settingsToApply* argument of the ``salobj.set_summary_state()`` call can be provided to assign the configuration profile (file), such as "default.yaml".
When you want to make sure the profile will be applied, it is better to switch to *STANDBY* state first [#]_.

.. [#] If the system is already in *ENABLED* state, state switch (and hence application of the profile) will not happen.

.. code:: python

    await salobj.set_summary_state(mtaosCsc, salobj.State.STANDBY)
    await salobj.set_summary_state(mtaosCsc, salobj.State.ENABLED, settingsToApply="default.yaml", timeout=30)

Configuration files (profiles) are stored in `MTAOS configuration <https://github.com/lsst-ts/ts_config_mttcs/tree/develop/MTAOS/v1>`_.
Notice that the version number (e.g. v1) is assigned in `ts_MTAOS schema <https://github.com/lsst-ts/ts_MTAOS/tree/master/schema>`_.

In the *ts_salobj* v6.0.3, the user can not create the **Remote** object in ipython directly.
Instead, you need to create an event loop by yourself and do the related instantiation.
For example,

.. code:: python

    import asyncio
    from lsst.ts import salobj

    async def createCsc():
        return salobj.Remote(salobj.Domain(), "MTAOS")

    loop = asyncio.get_event_loop()
    mtaosCsc = loop.run_until_complete(createCsc())

As CSC starts, ``Model`` or ``ModelSim`` object is created.
This requires reading a lot of data from the database in the butler, so MTAOS needs some time to finish the configuration.
It is better to provide a long (~30 seconds) timeout for the transition.

To issue a correction to the subsystems, do [#]_

.. [#] The *value* parameter will be removed in future versions of SAL

.. code:: python

    await mtaosCsc.cmd_issueCorrection.set_start(timeout=10, value=True)

*Timeout* is specified in seconds.
Default values are provided for all parameters.

For example:

.. code:: python

    await mtaosCsc.cmd_issueCorrection.set_start(timeout=10)

To call an another MTOAS command, use a cmd_*{nameOfCommand}* property. Such as:

.. code:: python

    await mtaosCsc.cmd_runWEP.set_start(timeout=10, parameters)

The *salobj.AckTimeoutError* exception will be thrown if *timeout* seconds passed and the command is not finished.
In the simulation mode It is safe to set the *timeout* parameter between 15 to 30 seconds.

MTAOS (SalObj) provides methods to wait for reception of the event.
Similarly to cmd handling, use a evt_*{nameOfEvent}* property.
For example, to wait for next DOF, call:

.. code:: python

    dof = await mtaosCsc.evt_degreeOfFreedom.next(flush=False, timeout=30)

The *next* method waits for a value, returning the oldest next value (if multiple events are received).
Use *aget* to retrieve the current value (or wait for any, if the event wasn't yet received):

.. code:: python

    dof = await mtaosCsc.evt_degreeOfFreedom.aget(timeout=30)

Telemetry is received using *tel_* prefix instead of *evt_*.

Adding Aberration
-----------------

The MTAOS provides a :py:meth:`addAberration <lsst.ts.MTAOS.MtaosCsc.cmd_addAberration>` command designed to allow users to add optical aberration to the system by providing an array of Zernike wavefront errors.

The coefficients provided by the user are first translated into a uniform aberration measured over the entire FoV (considering the current MTAOS configuration) and later processed by the ofc to provide the data to be sent to the components.
Using the ofc also allows the user-provided aberrations to be accounted for in the internal system state, improving the system interoperability.

To use this command the user would do:

.. code:: python

  # system accepts 19 zernike coefficients
  wf = np.zeros(19)

  wf[0] += 0.1 # add 0.1 um of defocus
  wf[1] += 0.1 # add 0.1 um of oblique astigmatism
  wf[2] += 0.1 # add 0.1 um of vertical astigmatism
  wf[3] += 0.1  # add 0.1 um of vertical coma
  wf[4] += 0.1  # add 0.1 um of horizontal coma
  wf[5] += 0.1  # add 0.1 um of vertical trefoil
  wf[6] += 0.1  # add 0.1 um of oblique trefoil

  ...

  await mtaosCsc.cmd_addAberration.set_start(wf=wf)

  await mtaosCsc.cmd_issueCorrection.start()

Note that the ``addAberration`` command itself does not send the corrections.
It only computes and store them in the model.
A user can send the corrections by sending a ``issueCorrection`` command, and ignore them with a ``resetCorrection``.

.. ofc: Need to provide a link for the ofc in the future.

.. note::

	The MTAOS uses Zernike Noll coefficients.

Further reading
===============

For further details, please see:

- `RemoteCommand <https://ts-salobj.lsst.io/py-api/lsst.ts.salobj.topics.RemoteCommand.html>`_
- `RemoteEvent <https://ts-salobj.lsst.io/py-api/lsst.ts.salobj.topics.RemoteEvent.html>`_
- `RemoteTelemetry <https://ts-salobj.lsst.io/py-api/lsst.ts.salobj.topics.RemoteTelemetry.html>`_
